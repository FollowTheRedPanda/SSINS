from SSINS import INS, util
import argparse
import csv
import numpy as np
from time import time

#This script takes a csv file (as can be generated by the highflag script) and outputs
#the occupancies of the input data as measured against specified filters.
#It is capable of automatically rejecting entries based on total_occ value, to remove
#uninteresting clean obs if desired.

global inputargs

#helper functions for file ops
def csv_to_dict_list(csv_filepath):

    with open(csv_filepath, newline='') as csv_file:
        dict_reader = csv.DictReader(csv_file)
        dict_list = []
        for row in dict_reader:
            dict_list.append(row)

    return(dict_list)


def dict_list_to_csv(dict_list, outpath, fieldnames):

    with open(outpath, 'w', newline='') as csv_file:
        writer = csv.DictWriter(csv_file, fieldnames)

        writer.writeheader()
        for row in dict_list:
            writer.writerow(row)

#main execution body
def row_routine(obs):
    obsid = obs['obsid']
    ins = INS(obs['ins_file'], mask_file=obs['mask_file'],
              match_events_file=obs['yml_file'])
    # if enabled, do fine channel/ time ignore for parts of the data
    if fine_channels_ignore is not None:
        freq_chans = np.arange(len(ins.freq_array))
        freq_chans = np.delete(freq_chans, fine_channels_ignore)
        ins.select(freq_chans=freq_chans)
    if time_ignore is not None:
        times = ins.time_array
        times = np.delete(times, time_ignore)
        ins.select(times=times)
    # need the total occ of the obs for accepting/rejecting based on --limit flag
    total_occ = np.mean(ins.metric_array.mask[:, :, 0])

    if total_occ >= inputargs.limit: #if inputargs.limit is passed, filter obs by total_occ
        obs_occ_dict = {'obsid': obsid, 'total_occ': total_occ}
        if inputargs.shapes is not None:
            for shape in inputargs.shapes:
                obs_occ_dict[shape] = len([event for event in ins.match_events if event[2] == shape]) / ins.metric_array.shape[0]
        occ_dict_list.append(obs_occ_dict)
        print("+ accepted "+obs['ins_file']) #prints + accepted or - rejected on left side of conout
    else:
        print("- rejected "+obs['ins_file'])

if __name__ == "__main__":

    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--shapes', nargs='*', help='The shapes to calculate occupancies for (pass as `-c SHAPE SHAPE SHAPE... <other inputargs>`')
    parser.add_argument('-c', '--csv', help='A csv whose columns are obsids, ins data files, ins masks, and yml files')
    parser.add_argument('-o', '--outfile', help='The name of the output csv that contains occupancy information (use absolute path)')
    parser.add_argument('-i', '--ch_ignore', help='A text file of fine frequency channels to ignore in occupancy calculation')
    parser.add_argument('-t', '--time_ignore', help='Times to ignore when calculating occupancy')
    parser.add_argument('-v', '--verbose', action='store_true', help="Toggles verbose console output of file processing progress.")
    parser.add_argument('-l', '--limit', type=float, default=0, help="Sets the minimum total_occ level to write to outfile (default: 0)")
    inputargs = parser.parse_args()

    #start timer if verbose
    if inputargs.verbose:
        start = time()

    dict_list = csv_to_dict_list(inputargs.csv)

    #set up ignored channels if present
    if inputargs.ch_ignore is not None:
        fine_channels_ignore = util.make_obslist(inputargs.ch_ignore)
        fine_channels_ignore = np.array(fine_channels_ignore).astype(int)
    else:
        fine_channels_ignore = None

    if inputargs.time_ignore is not None:
        time_ignore = util.make_obslist(inputargs.time_ignore)
        time_ignore = np.array(time_ignore).astype(float)
    else:
        time_ignore = None

    occ_dict_list = []

    for ins_filepath in ins_file_list:
        execbody(ins_filepath)


    dict_list_to_csv(occ_dict_list, inputargs.outfile, ['obsid', 'total_occ'] + [shape for shape in inputargs.shapes])

    if inputargs.verbose:
        print(f'Time taken: {time() - start}')
